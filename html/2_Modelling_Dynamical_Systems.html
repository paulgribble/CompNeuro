<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>2. Modelling Dynamical Systems</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="2. Modelling Dynamical Systems"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="fall 2012"/>
<meta name="author" content="Paul Gribble &amp; Dinant Kistemaker"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" type="text/css" href="mystyle.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
/**
 *
 * @source: http://orgmode.org/mathjax/MathJax.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 * Copyright (C) 2012  MathJax
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 */

/*
@licstart  The following is the entire license notice for the
JavaScript code below.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code below is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code below.
*/
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="http://www.gribblelab.org/compneuro/1_Dynamical_Systems.html"> UP </a>
 |
 <a accesskey="H" href="http://www.gribblelab.org/compneuro/index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">2. Modelling Dynamical Systems</h1>



<hr/>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Characterizing a System Using Differential Equations</a></li>
<li><a href="#sec-2">Integrating Differential Equations in Python/SciPy</a>
<ul>
<li><a href="#sec-2-1">The power of modelling and simulation</a></li>
</ul>
</li>
<li><a href="#sec-3">Lorenz Attractor</a></li>
<li><a href="#sec-4">Predator-Prey model</a></li>
<li><a href="#sec-5">Double Pendulum</a></li>
</ul>
</div>
</div>

<hr/>


<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Characterizing a System Using Differential Equations</h2>
<div class="outline-text-2" id="text-1">


<p>
A dynamical system such as the mass-spring system we saw before, can
be characterized by the relationship between state variables \(s\) and
their (time) derivatives \(\dot{s}\). How do we arrive at the correct
characterization of this relationship? The short answer is, we figure
it out using our knowledge of physics, or we are simply given the
equations by someone else. Let's look at a simple mass-spring system
again.
</p>

<div class="figure">
<p><img src="figs/spring-mass.png" height="200px" align="center" alt="figs/spring-mass.png" /></p>
<p>A spring with a mass attached</p>
</div>

<p>
We know a couple of things about this system. We know from <a href="http://en.wikipedia.org/wiki/Hooke's_law">Hooke's law</a>
of elasticity that the extension of a spring is directly and linearly
proportional to the load applied to it. More precisely, the force that
a spring applies in response to a perturbation from it's <i>resting length</i> (the length at which it doesn't generate any force), is
linearly proportional, through a constant \(k\), to the difference in
length between its current length and its resting length (let's call
this distance \(x\)). For convention let's assume positive values of \(x\)
correspond to lengthening the spring beyond its resting length, and
negative values of \(x\) correspond to shortening the spring from its
resting length.
</p>


\begin{equation}
F = -kx
\end{equation}

<p>
Let's decide that the <i>state variable</i> that we are interested in for
our system is \(x\). We will refer to \(x\) instead of \(s\) from now on to
denote our state variable.
</p>
<p>
We also know from <a href="http://en.wikipedia.org/wiki/Newton's_laws_of_motion">Newton's laws of motion</a> (specifically <a href="http://en.wikipedia.org/wiki/Newton's_laws_of_motion#Newton.27s_second_law">Newton's second law</a>) that the net force on an object is equal to its mass \(m\)
multiplied by its acceleration \(a\) (the second derivative of
position).
</p>


\begin{equation}
F = ma
\end{equation}

<p>
Instead of using \(a\) to denote acceleration let's use a different
notation, in terms of the spring's perturbed length \(x\). The rate of
change (velocity) is denoted \(\dot{x}\) and the rate of change of the
velocity (i.e. the acceleration) is denoted \(\ddot{x}\).
</p>


\begin{equation}
F = m \ddot{x}
\end{equation}

<p>
We also know that the mass is affected by two forces: the force due to
the spring (\(-kx\)) and also the gravitational force \(g\). So the
equation characterizing the <i>net forces</i> on the mass is
</p>


\begin{equation}
\sum{F} = m\ddot{x} = -kx + mg
\end{equation}

<p>
or just
</p>


\begin{equation}
m\ddot{x} = -kx + mg 
\end{equation}

<p>
This equation is a <i>second-order</i> differential equation, because the
highest state derivative is a <i>second derivative</i> (i.e. \(\ddot{x}\),
the second derivative, i.e. the acceleration, of \(x\)). The equation
specifies the relationship between the state variables (in this case a
single state variable \(x\)) and its derivatives (in this case a single
derivative, \(\ddot{x}\)).
</p>
<p>
The reason we want an equation like this, from a practical point of
view, is that we will be using numerical solvers in Python/Scipy to
<i>integrate</i> this differential equation over time, so that we can
<i>simulate</i> the behaviour of the system. What these solvers need is a
Python function that returns state derivatives, given current
states. We can re-arrange the equation above so that it specifies how
to compute the state derivative \(\ddot{x}\) given the current state
\(\ddot{x}\).
</p>


\begin{equation}
\ddot{x} = \frac{-kx}{m} + g
\end{equation}

<p>
Now we have what we need in order to simulate this system in
Python/Scipy. At any time point, we can compute the acceleration of
the mass by the formula above.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Integrating Differential Equations in Python/SciPy</h2>
<div class="outline-text-2" id="text-2">


<p>
Here is a Python function that we will be using to simulate the
mass-spring system. All it does, really, is compute the equation
above: what is the value of \(\ddot{x}\), given \(x\)? The one addition we
have is that we are going to keep track not just of one state variable
\(x\) but also its first derivative \(\dot{x}\) (the rate of change of
\(x\), i.e. velocity).
</p>



<pre class="src src-python"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">MassSpring</span>(state,t):
  <span style="color: #b22222;"># unpack the state vector</span>
  x = state[0]
  xd = state[1]

  <span style="color: #b22222;"># these are our constants</span>
  k = 2.5 <span style="color: #b22222;"># Newtons per metre</span>
  m = 1.5 <span style="color: #b22222;"># Kilograms</span>
  g = 9.8 <span style="color: #b22222;"># metres per second</span>

  <span style="color: #b22222;"># compute acceleration xdd</span>
  xdd = ((-k*x)/m) + g

  <span style="color: #b22222;"># return the two state derivatives</span>
  <span style="color: #a020f0;">return</span> [xd, xdd]
</pre>


<p>
Note that the function we wrote takes two arguments as inputs: <code>state</code>
and <code>t</code>, which corresponds to time. This is necessary for the
numerical solver that we will use in Python/Scipy. The <code>state</code>
variable is actually an <i>array</i> of two values corresponding to \(x\) and
\(\dot{x}\).
</p>
<p>
How does numerical integration (simulation) work? Here is a summary of the steps that a numerical solver takes. First, you have to provide the system with two things:
</p>
<ol>
<li>initial conditions (what are the initial states of the system?)
</li>
<li>a time vector over which to simulate
</li>
</ol>


<p>
Given this, the numerical solver will go through the following steps to simulate the system:
</p>
<ul>
<li>calculate state derivatives \(\ddot{x}\) at the initial time (\(t=0\))
  given the initial states \((x,\dot{x})\)
</li>
<li>estimate \(x(t+ \Delta t)\) using \(x(t=0)\), \(\dot{x}(t=0)\) and
  \(\ddot{x}(t=0)\)
</li>
<li>calculate \(\ddot{x}(t=t + \Delta t)\) from \(x(t=t + \Delta t)\) and
  \(\dot{x}(t=t + \Delta t)\)
</li>
<li>estimate \(x(t + 2 \Delta t)\) and \(\dot{x}(t + 2 \Delta t)\) using
  \(x(t=t + \Delta t)\), \(\dot{x}(t=t + \Delta t)\) and \(\ddot{x}(t=t +
  \Delta t)\)
</li>
<li>calculate \(\ddot{x}(t=t + 2\Delta t)\) from \(x(t=t + 2\Delta t)\) and
  \(\dot{x}(t=t + 2\Delta t)\)
</li>
<li>&hellip; etc
</li>
</ul>


<p>
In this way the numerical solver can esimate how the system states
\((x,\dot{x})\) unfold over time, given the initial conditions, and the
known relationship between state derivatives and system states. The
details of the "estimate" steps above are not something we are going
to dive into now. Suffice it to say that current estimation algorithms
are based on the work of two German mathematicians named <a href="http://en.wikipedia.org/wiki/Rungeâ€“Kutta_methods">Runge and Kutta</a> in the beginning of the 20th century. These numerical recipies
are readily available in Scipy (<a href="http://docs.scipy.org/doc/scipy/reference/integrate.html">docs here</a> (and in MATLAB, and other
numerical software) and are known as ODE solvers (ODE stands for
<i>ordinary differential equation</i>).
</p>
<p>
Here's how we would simulate the mass-spring system above. Launch
iPython with the <code>--pylab</code> argument (this automatically imports a
bunch of libraries that we will use, including plotting libraries).
</p>



<pre class="src src-python"><span style="color: #a020f0;">from</span> scipy.integrate <span style="color: #a020f0;">import</span> odeint

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">MassSpring</span>(state,t):
  <span style="color: #b22222;"># unpack the state vector</span>
  x = state[0]
  xd = state[1]

  <span style="color: #b22222;"># these are our constants</span>
  k = -2.5 <span style="color: #b22222;"># Newtons per metre</span>
  m = 1.5 <span style="color: #b22222;"># Kilograms</span>
  g = 9.8 <span style="color: #b22222;"># metres per second</span>

  <span style="color: #b22222;"># compute acceleration xdd</span>
  xdd = ((k*x)/m) + g

  <span style="color: #b22222;"># return the two state derivatives</span>
  <span style="color: #a020f0;">return</span> [xd, xdd]

<span style="color: #a0522d;">state0</span> = [0.0, 0.0]
<span style="color: #a0522d;">t</span> = arange(0.0, 10.0, 0.1)

<span style="color: #a0522d;">state</span> = odeint(MassSpring, state0, t)

plot(t, state)
xlabel(<span style="color: #8b2252;">'TIME (sec)'</span>)
ylabel(<span style="color: #8b2252;">'STATES'</span>)
title(<span style="color: #8b2252;">'Mass-Spring System'</span>)
legend((<span style="color: #8b2252;">'$x$ (m)'</span>, <span style="color: #8b2252;">'$\dot{x}$ (m/sec)'</span>))
</pre>


<p>
<a href="code/mass_spring.py">mass_spring.py</a>
</p>
<p>
A couple of notes about the code. I have simply chosen, out of the
blue, values for the constants \(k\) and \(m\). The <a href="http://en.wikipedia.org/wiki/Gravitational_constant">gravitational constant</a>
\(g\) is of course known. I have also chosen to simulate the system for
10 seconds, and I have chosen a time <i>resolution</i> of 100 milliseconds
(0.1 seconds). We will talk later about the issue of what is an
appropriate time resolution for simulation.
</p>
<p>
You should see a plot like this:
</p>

<div class="figure">
<p><img src="figs/mass-spring-sim.png" height="400px" align="center" alt="figs/mass-spring-sim.png" /></p>
<p>Mass-Spring Simulation</p>
</div>

<p>
The blue line shows the position \(x\) of the mass (the length of the
spring) over time, and the green line shows the rate of change of \(x\),
in other words the velocity \(\dot{x}\), over time. These are the two
states of the system, simulated over time.
</p>
<p>
The way to interpret this simulation is, if we start the system at
\(x=0\) and \(\dot{x}=0\), and simulate for 10 seconds, this is how the
system would behave.
</p>
<p>
<b>Questions</b>:
</p>
<ol>
<li>We have started the system at \(x=0\) which means that the spring is
   not stretched beyond its resting length (so spring force due to
   stretch should equal zero), and \(\dot{x}=0\), which means the
   spring's velocity is zero, i.e. it is not moving. Why does the
   simulation predict that the spring will begin stretching, then
   bouncing back and forth?

</li>
<li>What is the influence of the sign and magnitude of the stiffness
   parameter \(k\)?

</li>
<li>In physics, <a href="http://en.wikipedia.org/wiki/Damping">damping</a> can be used to reduce the magnitude of
   oscillations. Damping generates a force that is directly
   proportional to velocity (\(F = -b\dot{x}\)). Add damping to the
   mass-spring system and re-run the simulation. Specify the value of
   the damping constant \(b=-2.0\). What happens?

</li>
<li>What is the influence of the sign and magnitude of the damping
   coefficient \(b\)?

</li>
<li>Double the mass, and re-run the simulaton. What happens?

</li>
<li>How would you add an input force to the system?
</li>
</ol>



</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">The power of modelling and simulation</h3>
<div class="outline-text-3" id="text-2-1">


<p>
Now you can appreciate the power of mathematical models and
simulation: given a model that characterizes (to some degree of
accuracy) the behaviour of a system we are interested in, we can use
simulation to perform experiments <i>in simulation</i> instead of in
reality. This can be very powerful. We can ask questions of the model,
in simulation, that may be too difficult, or expensive, or time
consuming, or just plain impossible, to do in real-life empirical
studies. The degree to which we regard the results of simulations as
interpretable, is a direct reflection of the degree to which we
believe that our mathematical model is a reasonable characterization
of the behaviour of the real system.
</p>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Lorenz Attractor</h2>
<div class="outline-text-2" id="text-3">


<p>
The <a href="http://en.wikipedia.org/wiki/Lorenz_system">Lorenz system</a> is a dynamical system that we will look at briefly,
as it will allow us to discuss several interesting issues around
dynamical systems. It is a system often used to illustrate <a href="http://en.wikipedia.org/wiki/Nonlinear_system">non-linear systems</a> theory and <a href="http://en.wikipedia.org/wiki/Chaos_theory">chaos theory</a>. It's sometimes used as a simple
demonstration of the <a href="http://en.wikipedia.org/wiki/Butterfly_effect">butterfly effect</a> (sensitivity to initial
conditions).
</p>
<p>
The Lorenz system is a simplified mathematical model for atmospheric
convection. Let's not worry about the details of what it represents,
for now the important things to note are that it is a system of three
<i>coupled</i> differential equations, and characterizes a system with
three state variables \((x,y,z\)).
</p>


\begin{eqnarray}
\dot{x} &= &\sigma(y-x)\\
\dot{y} &= &(\rho-z)x - y\\
\dot{z} &= &xy-\beta z
\end{eqnarray}

<p>
If you set the three constants \((\sigma,\rho,\beta)\) to specific
values, the system exhibits <i>chaotic behaviour</i>.
</p>


\begin{eqnarray}
\sigma &= &10\\
\rho &= &28\\
\beta &= &\frac{8}{3}
\end{eqnarray}

<p>
Let's implement this system in Python/Scipy. We have been given above
the three equations that characterize how the state derivatives
\((\dot{x},\dot{y},\dot{z})\) depend on \((x,y,z)\) and the constants
\((\sigma,\rho,\beta)\). All we have to do is write a function that
implements this, set some initial conditions, decide on a time array
to simulate over, and run the simulation using <code>odeint()</code>.
</p>



<pre class="src src-python"><span style="color: #a020f0;">from</span> scipy.integrate <span style="color: #a020f0;">import</span> odeint

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">Lorenz</span>(state,t):
  <span style="color: #b22222;"># unpack the state vector</span>
  x = state[0]
  y = state[1]
  z = state[2]

  <span style="color: #b22222;"># these are our constants</span>
  sigma = 10.0
  rho = 28.0
  beta = 8.0/3.0

  <span style="color: #b22222;"># compute state derivatives</span>
  xd = sigma * (y-x)
  yd = (rho-z)*x - y
  zd = x*y - beta*z

  <span style="color: #b22222;"># return the state derivatives</span>
  <span style="color: #a020f0;">return</span> [xd, yd, zd]

<span style="color: #a0522d;">state0</span> = [2.0, 3.0, 4.0]
<span style="color: #a0522d;">t</span> = arange(0.0, 30.0, 0.01)

<span style="color: #a0522d;">state</span> = odeint(Lorenz, state0, t)

<span style="color: #b22222;"># do some fancy 3D plotting</span>
<span style="color: #a020f0;">from</span> mpl_toolkits.mplot3d <span style="color: #a020f0;">import</span> Axes3D
<span style="color: #a0522d;">fig</span> = figure()
<span style="color: #a0522d;">ax</span> = fig.gca(projection=<span style="color: #8b2252;">'3d'</span>)
ax.plot(state[:,0],state[:,1],state[:,2])
ax.set_xlabel(<span style="color: #8b2252;">'x'</span>)
ax.set_ylabel(<span style="color: #8b2252;">'y'</span>)
ax.set_zlabel(<span style="color: #8b2252;">'z'</span>)
show()
</pre>


<p>
<a href="code/lorenz1.py">lorenz1.py</a>
</p>
<p>
You should see something like this:
</p>

<div class="figure">
<p><img src="figs/lorenz1.png" height="600px" align="center" alt="figs/lorenz1.png" /></p>
<p>Lorenz Attractor</p>
</div>

<p>
The three axes on the plot represent the three states \((x,y,z)\)
plotted over the 30 seconds of simulated time. We started the system
with three particular values of \((x,y,z)\) (I chose them arbitrarily),
and we set the simulation in motion. This is the trajectory, in
<i>state-space</i>, of the Lorenz system.
</p>
<p>
You can see an interesting thing&hellip; the system seems to have two
stable equilibrium states, or attractors: those circular paths. The
system circles around in one "neighborhood" in state-space, and then
flips over and circles around the second neighborhood. The number of
times it circles in a given neighborhood, and the time at which it
switches, displays chaotic behaviour, in the sense that they are
exquisitly sensitive to initial conditions.
</p>
<p>
For example let's re-run the simulation but change the initial
conditions. Let's change them by a very small amount, say
0.0001&hellip; and let's only change the \(x\) initial state by that very
small amount. We will simulate for 30 seconds.
</p>



<pre class="src src-python"><span style="color: #a0522d;">t</span> = arange(0.0, 30, 0.01)

<span style="color: #b22222;"># original initial conditions</span>
<span style="color: #a0522d;">state1_0</span> = [2.0, 3.0, 4.0]
<span style="color: #a0522d;">state1</span> = odeint(Lorenz, state1_0, t)

<span style="color: #b22222;"># rerun with very small change in initial conditions</span>
<span style="color: #a0522d;">delta</span> = 0.0001
<span style="color: #a0522d;">state2_0</span> = [2.0+delta, 3.0, 4.0]
<span style="color: #a0522d;">state2</span> = odeint(Lorenz, state2_0, t)

<span style="color: #b22222;"># animation</span>
fig,ax = subplots()
pb, = ax.plot(state1[:,0],state1[:,1],<span style="color: #8b2252;">'b-'</span>,alpha=0.2)
xlabel(<span style="color: #8b2252;">'x'</span>)
ylabel(<span style="color: #8b2252;">'y'</span>)
p, = ax.plot(state1[0:10,0],state1[0:10,1],<span style="color: #8b2252;">'b-'</span>)
pp, = ax.plot(state1[10,0],state1[10,1],<span style="color: #8b2252;">'b.'</span>,markersize=10)
p2, = ax.plot(state2[0:10,0],state2[0:10,1],<span style="color: #8b2252;">'r-'</span>)
pp2, = ax.plot(state2[10,0],state2[10,1],<span style="color: #8b2252;">'r.'</span>,markersize=10)
<span style="color: #a0522d;">tt</span> = title(<span style="color: #8b2252;">"%4.2f sec"</span> % 0.00)
<span style="color: #b22222;"># animate</span>
<span style="color: #a0522d;">step</span>=3
<span style="color: #a020f0;">for</span> i <span style="color: #a020f0;">in</span> <span style="color: #7a378b;">xrange</span>(1,shape(state1)[0]-10,step):
  p.set_xdata(state1[10+i:20+i,0])
  p.set_ydata(state1[10+i:20+i,1])
  pp.set_xdata(state1[19+i,0])
  pp.set_ydata(state1[19+i,1])
  p2.set_xdata(state2[10+i:20+i,0])
  p2.set_ydata(state2[10+i:20+i,1])
  pp2.set_xdata(state2[19+i,0])
  pp2.set_ydata(state2[19+i,1])
  tt.set_text(<span style="color: #8b2252;">"%4.2f sec"</span> % (i*0.01))
  draw()

<span style="color: #a0522d;">i</span> = 1939          <span style="color: #b22222;"># the two simulations really diverge here!</span>
<span style="color: #a0522d;">s1</span> = state1[i,:]
<span style="color: #a0522d;">s2</span> = state2[i,:]
<span style="color: #a0522d;">d12</span> = norm(s1-s2) <span style="color: #b22222;"># distance</span>
<span style="color: #a020f0;">print</span> (<span style="color: #8b2252;">"distance = %f for a %f different in initial condition"</span>) % (d12, delta)
</pre>


<p>
<a href="code/lorenz2.py">lorenz2.py</a>
</p>



<pre class="example">distance = 32.757253 for a 0.000100 different in initial condition
</pre>


<p>
You should see an animation of the two state-space trajectories. For
convenience we are only plotting \(x\) vs \(y\) and ignoring \(z\). It turns
out that 3D animations are not trivial in matplotlib (there is a
library called mayavi that is excellent for 3D stuff).
</p>
<p>
The original simulation is shown in blue and the new one (in which the
initial condition of \(x\) was increased by 0.0001) in red. The two
follow each other quite closely for a long time, and then begin to
diverge at about the 16 second mark. At the end of the animation it
looks like this:
</p>

<div class="figure">
<p><img src="figs/lorenz2.png" height="400px" align="center" alt="figs/lorenz2.png" /></p>
<p>Lorenz Attractor</p>
</div>

<p>
At 19.39 seconds it looks like this:
</p>

<div class="figure">
<p><img src="figs/lorenz3.png" height="400px" align="center" alt="figs/lorenz3.png" /></p>
<p>Lorenz Attractor</p>
</div>

<p>
Note how the two systems are in different "neighborhoods" entirely!
</p>
<p>
At the end of the code above we compute the distance between the two
systems (the 3D distance between their respective \((x,y,z)\) positions
in state-space), and the distance is a whopping 32.76 units, for a
0.0001 difference in initial conditions.
</p>
<p>
This illustrates how systems with relatively simple differential
equations characterizing their behaviour, can turn out to be
exquisitely sensitive to initial conditions. Just imagine if the
initial conditions of your simulation were gathered from empirical
observations (like the weather, for example). Now imagine you use a
model simulation to predict whether it will be sunny (left-hand
"neighborhood" of the plot above) or thunderstorms (right-hand
"neighborhood"), 30 days from now. If the answer can flip between one
prediction and the other, based on a 1/10,000 different in
measurement, you had better be sure of your empirical measurement
instruments, when you make a prediction 30 days out! Actually this
won't even solve the problem, no matter how precise your
measurements. The point is that the system as a whole is very
sensitive to even tiny changes in initial conditions. This is why
short-term weather forecasts are relatively accurate, but forecasts
past a couple of days can turn out to be dead wrong.
</p>

</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Predator-Prey model</h2>
<div class="outline-text-2" id="text-4">


<p>
Lotka-Volterra
</p>

</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">Double Pendulum</h2>
<div class="outline-text-2" id="text-5">


<p>
simple 2-joint arm
</p>
</div>
</div>
</div>

<div id="postamble">
<hr />Paul Gribble &amp; Dinant Kistemaker | fall 2012<br>This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">work</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a><br><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png" /></a><br />
</div>
</body>
</html>
